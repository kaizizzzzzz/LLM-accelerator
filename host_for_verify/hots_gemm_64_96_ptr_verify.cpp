//=============================================================================
// Auto generated by Allo
//=============================================================================

// OpenCL utility layer include
#include "xcl2.hpp"
#include <algorithm>
#include <cstdio>
#include <iomanip>
#include <iostream>
#include <random>
#include <vector>

// Function to multiply matrices and verify result
void matrix_multiply_and_verify(
    const std::vector<float, aligned_allocator<float>> &in0,
    const std::vector<float, aligned_allocator<float>> &in1,
    const std::vector<float, aligned_allocator<float>> &out0) {
  std::vector<float> cpu_result(6144, 0);
  for (int i = 0; i < 64; ++i) {
    for (int j = 0; j < 96; ++j) {
      for (int k = 0; k < 96; ++k) {
        cpu_result[i * 96 + j] += in0[i * 96 + k] * in1[k * 96 + j];
      }
    }
  }

  // Compare the result
  bool match = true;
  for (int i = 0; i < 6144; ++i) {
    if (std::abs(cpu_result[i] - out0[i]) > 1e-5) {
      match = false;
      break;
    }
  }

  if (match) {
    std::cout << "Matrix multiplication result is correct.\n";
  } else {
    std::cout << "Matrix multiplication result is incorrect.\n";
  }
}

int main(int argc, char **argv) {
  if (argc != 2) {
    std::cout << "Usage: " << argv[0] << " <XCLBIN File>" << std::endl;
    return EXIT_FAILURE;
  }

  std::string binaryFile = argv[1];
  cl_int err;
  cl::CommandQueue q;
  cl::Context context;
  cl::Program program;
  cl::Kernel krnl_fake_top;
  // Allocate Memory in Host Memory
  size_t size_bytes_in0 = sizeof(float) * 6144;
  std::vector<float, aligned_allocator<float>> source_in0(6144);
  size_t size_bytes_in1 = sizeof(float) * 9216;
  std::vector<float, aligned_allocator<float>> source_in1(9216);
  size_t size_bytes_out0 = sizeof(float) * 6144;
  std::vector<float, aligned_allocator<float>> source_out0(6144);

  // Initialize input data with random values
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_real_distribution<> dis(0, 1);
  for (int i = 0; i < 6144; ++i) {
    source_in0[i] = dis(gen);
  }
  for (int i = 0; i < 9216; ++i) {
    source_in1[i] = dis(gen);
  }

  // OPENCL HOST CODE AREA START
  auto devices = xcl::get_xil_devices();
  auto fileBuf = xcl::read_binary_file(binaryFile);
  cl::Program::Binaries bins{{fileBuf.data(), fileBuf.size()}};
  bool valid_device = false;
  for (unsigned int i = 0; i < devices.size(); i++) {
    auto device = devices[i];
    OCL_CHECK(err,
              context = cl::Context(device, nullptr, nullptr, nullptr, &err));
    OCL_CHECK(err, q = cl::CommandQueue(context, device,
                                        CL_QUEUE_PROFILING_ENABLE, &err));
    std::cout << "Trying to program device[" << i
              << "]: " << device.getInfo<CL_DEVICE_NAME>() << std::endl;
    cl::Program program(context, {device}, bins, nullptr, &err);
    if (err != CL_SUCCESS) {
      std::cout << "Failed to program device[" << i << "] with xclbin file!\n";
    } else {
      std::cout << "Device[" << i << "]: program successful!\n";
      OCL_CHECK(err, krnl_fake_top = cl::Kernel(program, "fake_top", &err));
      valid_device = true;
      break;
    }
  }
  if (!valid_device) {
    std::cout << "Failed to program any device found, exit!\n";
    exit(EXIT_FAILURE);
  }
  OCL_CHECK(err, cl::Buffer buffer_in0(
                     context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY,
                     size_bytes_in0, source_in0.data(), &err));
  OCL_CHECK(err, cl::Buffer buffer_in1(
                     context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY,
                     size_bytes_in1, source_in1.data(), &err));
  OCL_CHECK(err, cl::Buffer buffer_out0(
                     context, CL_MEM_USE_HOST_PTR | CL_MEM_WRITE_ONLY,
                     size_bytes_out0, source_out0.data(), &err));

  OCL_CHECK(err, err = krnl_fake_top.setArg(0, buffer_in0));
  OCL_CHECK(err, err = krnl_fake_top.setArg(1, buffer_in1));
  OCL_CHECK(err, err = krnl_fake_top.setArg(2, buffer_out0));

  OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_in0, buffer_in1},
                                                  0 /* 0 means from host*/));

  cl::Event event;
  uint64_t nstimestart, nstimeend;
  std::cout << "|-------------------------+-------------------------|\n"
            << "| Kernel                  |    Wall-Clock Time (ns) |\n"
            << "|-------------------------+-------------------------|\n";

  OCL_CHECK(err, err = q.enqueueTask(krnl_fake_top, nullptr, &event));

  OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_out0},
                                                  CL_MIGRATE_MEM_OBJECT_HOST));
  q.finish();

  OCL_CHECK(err, err = event.getProfilingInfo<uint64_t>(
                     CL_PROFILING_COMMAND_START, &nstimestart));
  OCL_CHECK(err, err = event.getProfilingInfo<uint64_t>(
                     CL_PROFILING_COMMAND_END, &nstimeend));
  auto exe_time = nstimeend - nstimestart;
  std::cout << "| " << std::left << std::setw(24) << "fake_top " << "|"
            << std::right << std::setw(24) << exe_time << " |\n";
  std::cout << "|-------------------------+-------------------------|\n";
  std::cout
      << "Note: Wall Clock Time is meaningful for real hardware execution "
      << "only, not for emulation.\n";
  std::cout << "Please refer to profile summary for kernel execution time for "
            << "hardware emulation.\n";

  // Verify the result
  matrix_multiply_and_verify(source_in0, source_in1, source_out0);

  std::cout << "TEST PASSED\n\n";
  return EXIT_SUCCESS;
}
